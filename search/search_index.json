{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DEVASC Data Encoding Formats Hands-On Lab Guide \u00b6 Overview \u00b6 When we automate to IT systems, we get the fantastic benefit of not having to either copy and paste configuration changes to dozens (maybe hundreds) of different systems or repeat the same click, click, click, click, click-through-the- UI marathon over, and over, and over... every single time there's a need to make a bulk change . To automate these sorts of workflows, it's important that we learn to write some form of automation-specific code. To make that possible, it's essential that we know how to read and write the data structures that our code sends to and receives from the systems we automate. This guide will walk you through some hands-on exercises which help teach and practice and give you a place to practice using various data encoding formats with Python. You'll get the most from these exercises if you have at least a little bit of exposure to Python fundamentals although we put the step-by-step directions together in a way that welcomes all experience levels. Unstructured vs Structured Data \u00b6 Data Meant for Humans to Read \u00b6 When we interact with the CLI of a network device, server, storage system, cloud compute platform, etc., we typically send text commands and receive text responses. Usually, the responses to our commands are plain text in an unstructured format. Most times we see the raw data response formatted with a variety of spaces, tabs, numbering, tables, or even text-based graphics, to make it easier for humans to read. Data Meant for Computers to Read \u00b6 When a computer, such as an automtion system, tries to read that same, unstructured data, we usually have to tell the computer specifically how it should search (or parse) through all of the spaces, special characters, and text graphics to find the specific, raw data it needs. Parsing through unstructured data is often difficult to configure, temperamental to successfully test, and a headache to maintain. Anytime an IT system undergoes a software or hardware change, the format of an unstructured command response can change, even if by a single character, and cause a parser to fail or work improperly. APIs and Data Formats \u00b6 So, how do we implement IT automation workflows and avoid having our lives comsumed by the \"joy\" of writing and maintaining text parsers? Fortunately, most IT systems have programmatic interfaces, referred to as APIs , which can send and receive configuration or state/status data in a structured format. Some of the more common structured data formats include JSON , XML , and YAML . Each of these structured data encoding formats are much easier for computers to read because the structure of the data adheres to a standard format which IT systems and programming languages can read without text parsers. A Practical Example \u00b6 Here is a real example of some data that a network device sent in response to a request from each its CLI and its API . Now, unless you happen to be a computer, you will probably find the CLI example ( unstructured data ) a bit easier to read than the API example ( structured data ). A Side-by-Side Comparision \u00b6 Example Network Device CLI and API Response Data Even though the CLI and API data formats look drastically different, they both provide the exact same data. CLI Response Output - Unstructured Data interface Ethernet1/10 ip access-group WEB-SERVER out ! IP access list WEB-SERVER 20 permit icmp 192.168.2.0/24 192.168.5.3/32 ! API Response Output - Structured Data <?xml version=\"1.0\" encoding=\"UTF-8\"?> <rpc-reply xmlns:nxos= \"http://www.cisco.com/nxos:1.0\" xmlns:if= \"http://www.cisco.com/nxos:1.0:if_manager\" xmlns:nfcli= \"http://www.cisco.com/nxos:1.0:nfcli\" xmlns:vlan_mgr_cli= \"http://www.cisco.com/nxos:1.0:vlan_mgr_cli\" xmlns= \"urn:ietf:params:xml:ns:netconf:base:1.0\" message-id= \"urn:uuid:abe5a744-a857-4dbd-ba4e-c96260f5fc5b\" > <data> <acl xmlns= \"http://openconfig.net/yang/acl\" > <interfaces> <interface> <id> eth1/10 </id> <config> <id> eth1/10 </id> </config> <egress-acl-sets> <egress-acl-set> <set-name> WEB-SERVER </set-name> <type> ACL_IPV4 </type> <config> <set-name> WEB-SERVER </set-name> <type> ACL_IPV4 </type> </config> </egress-acl-set> </egress-acl-sets> <interface-ref> <config> <interface> eth1/10 </interface> </config> </interface-ref> </interface> </interfaces> <acl-sets> <acl-set> <name> WEB-SERVER </name> <type> ACL_IPV4 </type> <acl-entries> <acl-entry> <sequence-id> 20 </sequence-id> <actions> <config> <forwarding-action> ACCEPT </forwarding-action> </config> </actions> <config> <sequence-id> 20 </sequence-id> </config> <ipv4> <config> <destination-address> 192.168.5.3/32 </destination-address> <protocol> IP_ICMP </protocol> <source-address> 192.168.2.0/24 </source-address> </config> </ipv4> </acl-entry> </acl-entries> <config> <name> WEB-SERVER </name> <type> ACL_IPV4 </type> </config> </acl-set> </acl-sets> </acl> </data> </rpc-reply> Comparing the Code \u00b6 If you're thinking, \"Why would I ever want to deal with structured data ? It looks like a mess!\" Well, to put it simply, structured data is way easier to work with programmatically . Take a look at how we might parse both the CLI and API responses with some Python code: Example Code Exercise The goal of this exercise is to parse the interface ID from each the CLI and API response data sets. For reference, the correct result of a search for the interface ID is the text 1/10 . These examples assume the CLI and API data are already available to the Python interpreter, in the variable with the name data . Even though the CLI response data is only a few lines long, the Python code to parse the interface ID from that data, with a regular expression, is lengthy and somewhat complex to read. By contrast, even though the API response data is lenghty, the Python code to parse the interface ID is short and far less complex to read. Click to view the code examples Parse the Unstructured ( CLI ) Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # CLI response data = cli_response # Regular expression search import re search_pattern = re . compile ( r ''' ^ # Search from the beginning of the line (\\D+ # Start match group 1, match 1 or more non-digits \\s # Match a single space character \\D+) # Match 1 or more non-digits, end match group 1 ([0-9] # Start match group 2, match any single digit \\/ # Match a single forward slash [0-9] {2} ) # Match any two digits, end match group 2 \\n # Match the end of the line ''' , re . VERBOSE ) search_result = search_pattern . search ( data ) try : interface_name = search_result . group ( 2 ) except AttributeError : pass Parsing the Structured ( API ) Response 1 2 3 4 5 6 7 8 # API response data = api_data [ 'rpc_reply' ] # Extract the interface name try : interface_name = data [ 'acl' ][ 'interfaces' ][ 'interface' ][ 'id' ] except KeyError : pass All right, that's enough reading for now. It's time to get into the lab exercises and get some real practice. If everything to this point makes perfect sense to you, great! If not, don't worry because you're about to get a lot of hands-on repetitions with functional code. Click here to continue to the next section .","title":"About"},{"location":"#devasc-data-encoding-formats-hands-on-lab-guide","text":"","title":"DEVASC Data Encoding Formats Hands-On Lab Guide"},{"location":"#overview","text":"When we automate to IT systems, we get the fantastic benefit of not having to either copy and paste configuration changes to dozens (maybe hundreds) of different systems or repeat the same click, click, click, click, click-through-the- UI marathon over, and over, and over... every single time there's a need to make a bulk change . To automate these sorts of workflows, it's important that we learn to write some form of automation-specific code. To make that possible, it's essential that we know how to read and write the data structures that our code sends to and receives from the systems we automate. This guide will walk you through some hands-on exercises which help teach and practice and give you a place to practice using various data encoding formats with Python. You'll get the most from these exercises if you have at least a little bit of exposure to Python fundamentals although we put the step-by-step directions together in a way that welcomes all experience levels.","title":" Overview"},{"location":"#unstructured-vs-structured-data","text":"","title":" Unstructured vs Structured Data"},{"location":"#data-meant-for-humans-to-read","text":"When we interact with the CLI of a network device, server, storage system, cloud compute platform, etc., we typically send text commands and receive text responses. Usually, the responses to our commands are plain text in an unstructured format. Most times we see the raw data response formatted with a variety of spaces, tabs, numbering, tables, or even text-based graphics, to make it easier for humans to read.","title":"Data Meant for Humans to Read"},{"location":"#data-meant-for-computers-to-read","text":"When a computer, such as an automtion system, tries to read that same, unstructured data, we usually have to tell the computer specifically how it should search (or parse) through all of the spaces, special characters, and text graphics to find the specific, raw data it needs. Parsing through unstructured data is often difficult to configure, temperamental to successfully test, and a headache to maintain. Anytime an IT system undergoes a software or hardware change, the format of an unstructured command response can change, even if by a single character, and cause a parser to fail or work improperly.","title":"Data Meant for Computers to Read"},{"location":"#apis-and-data-formats","text":"So, how do we implement IT automation workflows and avoid having our lives comsumed by the \"joy\" of writing and maintaining text parsers? Fortunately, most IT systems have programmatic interfaces, referred to as APIs , which can send and receive configuration or state/status data in a structured format. Some of the more common structured data formats include JSON , XML , and YAML . Each of these structured data encoding formats are much easier for computers to read because the structure of the data adheres to a standard format which IT systems and programming languages can read without text parsers.","title":"APIs and Data Formats"},{"location":"#a-practical-example","text":"Here is a real example of some data that a network device sent in response to a request from each its CLI and its API . Now, unless you happen to be a computer, you will probably find the CLI example ( unstructured data ) a bit easier to read than the API example ( structured data ).","title":" A Practical Example"},{"location":"#a-side-by-side-comparision","text":"Example Network Device CLI and API Response Data Even though the CLI and API data formats look drastically different, they both provide the exact same data. CLI Response Output - Unstructured Data interface Ethernet1/10 ip access-group WEB-SERVER out ! IP access list WEB-SERVER 20 permit icmp 192.168.2.0/24 192.168.5.3/32 ! API Response Output - Structured Data <?xml version=\"1.0\" encoding=\"UTF-8\"?> <rpc-reply xmlns:nxos= \"http://www.cisco.com/nxos:1.0\" xmlns:if= \"http://www.cisco.com/nxos:1.0:if_manager\" xmlns:nfcli= \"http://www.cisco.com/nxos:1.0:nfcli\" xmlns:vlan_mgr_cli= \"http://www.cisco.com/nxos:1.0:vlan_mgr_cli\" xmlns= \"urn:ietf:params:xml:ns:netconf:base:1.0\" message-id= \"urn:uuid:abe5a744-a857-4dbd-ba4e-c96260f5fc5b\" > <data> <acl xmlns= \"http://openconfig.net/yang/acl\" > <interfaces> <interface> <id> eth1/10 </id> <config> <id> eth1/10 </id> </config> <egress-acl-sets> <egress-acl-set> <set-name> WEB-SERVER </set-name> <type> ACL_IPV4 </type> <config> <set-name> WEB-SERVER </set-name> <type> ACL_IPV4 </type> </config> </egress-acl-set> </egress-acl-sets> <interface-ref> <config> <interface> eth1/10 </interface> </config> </interface-ref> </interface> </interfaces> <acl-sets> <acl-set> <name> WEB-SERVER </name> <type> ACL_IPV4 </type> <acl-entries> <acl-entry> <sequence-id> 20 </sequence-id> <actions> <config> <forwarding-action> ACCEPT </forwarding-action> </config> </actions> <config> <sequence-id> 20 </sequence-id> </config> <ipv4> <config> <destination-address> 192.168.5.3/32 </destination-address> <protocol> IP_ICMP </protocol> <source-address> 192.168.2.0/24 </source-address> </config> </ipv4> </acl-entry> </acl-entries> <config> <name> WEB-SERVER </name> <type> ACL_IPV4 </type> </config> </acl-set> </acl-sets> </acl> </data> </rpc-reply>","title":" A Side-by-Side Comparision"},{"location":"#comparing-the-code","text":"If you're thinking, \"Why would I ever want to deal with structured data ? It looks like a mess!\" Well, to put it simply, structured data is way easier to work with programmatically . Take a look at how we might parse both the CLI and API responses with some Python code: Example Code Exercise The goal of this exercise is to parse the interface ID from each the CLI and API response data sets. For reference, the correct result of a search for the interface ID is the text 1/10 . These examples assume the CLI and API data are already available to the Python interpreter, in the variable with the name data . Even though the CLI response data is only a few lines long, the Python code to parse the interface ID from that data, with a regular expression, is lengthy and somewhat complex to read. By contrast, even though the API response data is lenghty, the Python code to parse the interface ID is short and far less complex to read. Click to view the code examples Parse the Unstructured ( CLI ) Response 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # CLI response data = cli_response # Regular expression search import re search_pattern = re . compile ( r ''' ^ # Search from the beginning of the line (\\D+ # Start match group 1, match 1 or more non-digits \\s # Match a single space character \\D+) # Match 1 or more non-digits, end match group 1 ([0-9] # Start match group 2, match any single digit \\/ # Match a single forward slash [0-9] {2} ) # Match any two digits, end match group 2 \\n # Match the end of the line ''' , re . VERBOSE ) search_result = search_pattern . search ( data ) try : interface_name = search_result . group ( 2 ) except AttributeError : pass Parsing the Structured ( API ) Response 1 2 3 4 5 6 7 8 # API response data = api_data [ 'rpc_reply' ] # Extract the interface name try : interface_name = data [ 'acl' ][ 'interfaces' ][ 'interface' ][ 'id' ] except KeyError : pass All right, that's enough reading for now. It's time to get into the lab exercises and get some real practice. If everything to this point makes perfect sense to you, great! If not, don't worry because you're about to get a lot of hands-on repetitions with functional code. Click here to continue to the next section .","title":" Comparing the Code"},{"location":"sections/section_1/","text":"Getting Started With The Lab \u00b6 Lab Overview \u00b6 The lab environment runs in a Docker Container which hosts a web-based, interactive Python environment called JupyterLab . The JupyterLab server will allow you to work through a series of Python-based, data encoding formats exercises using your web browser. Lab Requirements \u00b6 You only need a few things to start working through the labs: A Docker runtime environment. Docker Desktop for Windows or macOS , Docker for Linux , etc. A web browser with JupyterLab support . You may run the lab Docker Container in: The WWT Programmability Foundations On-Demand Lab Your own Docker environment. A Visual Studio Code Development Container Lab Setup Instructions \u00b6 We provide instructions for three different lab setup options. Choose the option that best suits your needs and then follow the step-by-step directions: Lab Setup Options Option #1: Auto-provision the environment in the WWT Programmability Foundations Lab. Option #2: Run a pre-built Container in your own Docker runtime environment. Option #3: Use the Visual Studio Code Development Container in the Git Repository . Option #1 Auto-provision the environment in the WWT Programmability Foundations Lab Step 1 Launch a new copy of the WWT Programmability Foundations On-Demand Lab and click View Labs : Step 2 From the My Labs page, click Access Lab : Step 3 Click the Open in ATC Lab Gateway button : Step 4 If prompted, log on with your WWT.com Platform Account Credentials : Step 5 Click the System Tray icon and mouse over the Docker icon to reveal the service status: Attention The icon may take a minute or so to appear. Step 6 The Docker service is ready when a small exclamation point appears over the Docker icon : Attention It may be a few minutes before the Docker service is ready. Important Occasionally, the Docker Desktop service does not start on its own. Windows may ask you if you want to start the Docker service and thereafter request permission for Net Command\u200b to run. You may safely confirm both actions. Step 7 A PowerShell script will customize the lab environment automatically although and you need to paste a long command into a PowerShell window in order to start that process: Tip Click the PowerShell icon in the task bar to open a new PowerShell window. Then, copy the entire command below to your clipboard. Right-click in the PowerShell window to paste the command Press your Return/Enter key to run the command. Set-Executionpolicy -Scope CurrentUser -ExecutionPolicy UnRestricted -Force ; Set-Location \\ Users \\ admin ; Invoke-WebRequest -Uri 'https://devasc-data-formats.s3-us-west-2.amazonaws.com/setup_lab.ps1' -OutFile ' setup_lab . ps1 \u2019 ; .\\ setup_lab . ps1 What to do if you see a Docker Desktop process is not running error message: From time-to-time, Windows takes a lenghty amount of time to successfully start the Docker Desktop process and rarely, Windows will fail to start Docker Desktop. If Windows cannot start Docker Desktop, your first indication will be an error message when you run the PowerShell script which configures the lab. As the error message indicates, PowerShell will attempt to start or restart the Docker Desktop process. After a few seconds, the Docker Desktop application will open behind the PowerShell and you may bring it to the foreground to monitor the status. Docker for Windows Process Status A teal-colored icon in the lower-left corner of the Docker Desktop application indicates the Docker process is running and you should be able to re-run the PowerShell script to configure the lab environment. Sometimes, Windows takes 5-10 minutes to start the Docker process. An orange-colored icon in the lower-left corner of the Docker Desktop application indicates the Docker process is not running and you have a couple of options: Wait for around 10 minutes, to see if Windows is able to start the Docker process. Launch a new instance of the WWT Programmability Foundations On-Demand Lab . Step 8 Wait a few minutes for the automated lab setup to complete: Step 9 Within a few minutes, when the lab is ready to use, a Chrome browser will open a JupyterLab URL . Open the devasc-data-formats folder from the navigation pane: Step 10 Next, open the lab folder: Step 11 Open the part_i_python folder: Step 12 Open the file python.ipynb and begin working through the step-by-step instructions in the main pane: Lab Restart Instructions The lab setup process creates a shotcut on the Windows desktop which will help you restore the lab environment, in the event the JupyterLab browser tab closes, Windows restarts, etc. Notice The Restart Lab shortcut re-launches JupyterLab (including the Chrome browser tab) and will only take a few seconds to complete. Double-clicking this shortcut will NOT cause you to lose any of your lab progress. Option #2 Run a pre-built Container in your own Docker runtime environment Attention This option assumes you have an operational Docker runtime environment and that your Docker daemon can connect to and download images from Docker Hub . The screenshots in the directions represent an example from a macOS Terminal and the same commands and procedures also work with Windows PowerShell . Step 1 Copy the following command to your clipboard. Open a terminal shell on the same system as your Docker runtime environment. Paste the command into your terminal shell. Run the command. docker run -itp 8888 :8888 --name data-formats wwt01/devasc-data-formats Docker Command Details The Docker Command performs the following actions: Downloas the wwt01/devasc-data-formats Docker Image from Docker Hub . Creates a new Docker Container with the name data-formats Attaches to the Container shell. Starts a JupyterLab server in the Container on TCP port 8888 . Forwards incoming connections to your computer on ( localhost/127.0.0.1) on TCP port 8888 to the JupyterLab server in the Container. Step 2 Look for the following output to confirm the JupyterLab server is online and ready for incoming connections: Step 3 Open a web browser on your Docker runtime host. Navigate to the Container's JupyterLab server at http://localhost:8888 . Double-click on the part_i_python folder in the navigation pane. Step 4 Open the file python.ipynb and begin working through the step-by-step instructions in the main pane: Lab Environment Shutdown and Restart To shutdown the lab environment, return to your terminal window and press Ctrl + C twice, within 5 seconds . Lab Environment Docker Command Reference Use the following commands to manage your Docker lab environment: Restart an existing lab environment Container (restores previous lab progress): docker start data-formats Delete an existing lab environment Container (removes previous lab progress): docker stop data-formats docker rm data-formats Remove the Docker Image: docker stop data-formats docker rm data-formats docker rmi wwt01/devasc-data-formats Option #3 Use the Visual Studio Code Development Container in the Git Repository Attention This option assumes your computer/development environment has the following software installed and in a functional state: Visual Studio Code version 1.5 or later . Git version control . A Docker runtime environment such as Docker Desktop for Windows or macOS , Docker for Linux , etc.. WWT Programmability Foundations On-Demand Lab Requirements If you intend to use these instructions with the WWT Programmability Foundations On-Demand Lab , take note of the following advisories: The Visual Studio Code installation on the WWT Programmability Foundations On-Demand Lab requires an upgrade before it will successfully launch this development container. The WWT Programmability Foundations On-Demand Lab does not have Git for Windows pre-installed . The screenshots in the directions represent an example from a Microsoft Windows computer and the same procedures also work with macOS and Linux . Step 1 Clone the Git Repository : git clone https://github.com/wwt/devasc-data-formats.git // Insert image Step 2 Open Visual Studio Code: // Insert image Step 3 Install the Remote Development Pack Extension ms-vscode-remote.vscode-remote-extensionpack // Insert image Step 4 Initiate the Development Container Startup Process: // Insert image Step 5 Choose the Path to the cloned Git Repository: // Insert image Step 6 Open a web browser on your Docker runtime host. Navigate to the Container's JupyterLab server at http://localhost:8888 . Double-click on the part_i_python folder in the navigation pane. // Insert image Step 7 Open the file python.ipynb and begin working through the step-by-step instructions in the main pane: // Insert image Lab Environment Shutdown Close the Development Environment Container // Insert image","title":"Hands-On Lab Setup"},{"location":"sections/section_1/#getting-started-with-the-lab","text":"","title":"Getting Started With The Lab"},{"location":"sections/section_1/#lab-overview","text":"The lab environment runs in a Docker Container which hosts a web-based, interactive Python environment called JupyterLab . The JupyterLab server will allow you to work through a series of Python-based, data encoding formats exercises using your web browser.","title":" Lab Overview"},{"location":"sections/section_1/#lab-requirements","text":"You only need a few things to start working through the labs: A Docker runtime environment. Docker Desktop for Windows or macOS , Docker for Linux , etc. A web browser with JupyterLab support . You may run the lab Docker Container in: The WWT Programmability Foundations On-Demand Lab Your own Docker environment. A Visual Studio Code Development Container","title":" Lab Requirements"},{"location":"sections/section_1/#lab-setup-instructions","text":"We provide instructions for three different lab setup options. Choose the option that best suits your needs and then follow the step-by-step directions: Lab Setup Options Option #1: Auto-provision the environment in the WWT Programmability Foundations Lab. Option #2: Run a pre-built Container in your own Docker runtime environment. Option #3: Use the Visual Studio Code Development Container in the Git Repository . Option #1 Auto-provision the environment in the WWT Programmability Foundations Lab Step 1 Launch a new copy of the WWT Programmability Foundations On-Demand Lab and click View Labs : Step 2 From the My Labs page, click Access Lab : Step 3 Click the Open in ATC Lab Gateway button : Step 4 If prompted, log on with your WWT.com Platform Account Credentials : Step 5 Click the System Tray icon and mouse over the Docker icon to reveal the service status: Attention The icon may take a minute or so to appear. Step 6 The Docker service is ready when a small exclamation point appears over the Docker icon : Attention It may be a few minutes before the Docker service is ready. Important Occasionally, the Docker Desktop service does not start on its own. Windows may ask you if you want to start the Docker service and thereafter request permission for Net Command\u200b to run. You may safely confirm both actions. Step 7 A PowerShell script will customize the lab environment automatically although and you need to paste a long command into a PowerShell window in order to start that process: Tip Click the PowerShell icon in the task bar to open a new PowerShell window. Then, copy the entire command below to your clipboard. Right-click in the PowerShell window to paste the command Press your Return/Enter key to run the command. Set-Executionpolicy -Scope CurrentUser -ExecutionPolicy UnRestricted -Force ; Set-Location \\ Users \\ admin ; Invoke-WebRequest -Uri 'https://devasc-data-formats.s3-us-west-2.amazonaws.com/setup_lab.ps1' -OutFile ' setup_lab . ps1 \u2019 ; .\\ setup_lab . ps1 What to do if you see a Docker Desktop process is not running error message: From time-to-time, Windows takes a lenghty amount of time to successfully start the Docker Desktop process and rarely, Windows will fail to start Docker Desktop. If Windows cannot start Docker Desktop, your first indication will be an error message when you run the PowerShell script which configures the lab. As the error message indicates, PowerShell will attempt to start or restart the Docker Desktop process. After a few seconds, the Docker Desktop application will open behind the PowerShell and you may bring it to the foreground to monitor the status. Docker for Windows Process Status A teal-colored icon in the lower-left corner of the Docker Desktop application indicates the Docker process is running and you should be able to re-run the PowerShell script to configure the lab environment. Sometimes, Windows takes 5-10 minutes to start the Docker process. An orange-colored icon in the lower-left corner of the Docker Desktop application indicates the Docker process is not running and you have a couple of options: Wait for around 10 minutes, to see if Windows is able to start the Docker process. Launch a new instance of the WWT Programmability Foundations On-Demand Lab . Step 8 Wait a few minutes for the automated lab setup to complete: Step 9 Within a few minutes, when the lab is ready to use, a Chrome browser will open a JupyterLab URL . Open the devasc-data-formats folder from the navigation pane: Step 10 Next, open the lab folder: Step 11 Open the part_i_python folder: Step 12 Open the file python.ipynb and begin working through the step-by-step instructions in the main pane: Lab Restart Instructions The lab setup process creates a shotcut on the Windows desktop which will help you restore the lab environment, in the event the JupyterLab browser tab closes, Windows restarts, etc. Notice The Restart Lab shortcut re-launches JupyterLab (including the Chrome browser tab) and will only take a few seconds to complete. Double-clicking this shortcut will NOT cause you to lose any of your lab progress. Option #2 Run a pre-built Container in your own Docker runtime environment Attention This option assumes you have an operational Docker runtime environment and that your Docker daemon can connect to and download images from Docker Hub . The screenshots in the directions represent an example from a macOS Terminal and the same commands and procedures also work with Windows PowerShell . Step 1 Copy the following command to your clipboard. Open a terminal shell on the same system as your Docker runtime environment. Paste the command into your terminal shell. Run the command. docker run -itp 8888 :8888 --name data-formats wwt01/devasc-data-formats Docker Command Details The Docker Command performs the following actions: Downloas the wwt01/devasc-data-formats Docker Image from Docker Hub . Creates a new Docker Container with the name data-formats Attaches to the Container shell. Starts a JupyterLab server in the Container on TCP port 8888 . Forwards incoming connections to your computer on ( localhost/127.0.0.1) on TCP port 8888 to the JupyterLab server in the Container. Step 2 Look for the following output to confirm the JupyterLab server is online and ready for incoming connections: Step 3 Open a web browser on your Docker runtime host. Navigate to the Container's JupyterLab server at http://localhost:8888 . Double-click on the part_i_python folder in the navigation pane. Step 4 Open the file python.ipynb and begin working through the step-by-step instructions in the main pane: Lab Environment Shutdown and Restart To shutdown the lab environment, return to your terminal window and press Ctrl + C twice, within 5 seconds . Lab Environment Docker Command Reference Use the following commands to manage your Docker lab environment: Restart an existing lab environment Container (restores previous lab progress): docker start data-formats Delete an existing lab environment Container (removes previous lab progress): docker stop data-formats docker rm data-formats Remove the Docker Image: docker stop data-formats docker rm data-formats docker rmi wwt01/devasc-data-formats Option #3 Use the Visual Studio Code Development Container in the Git Repository Attention This option assumes your computer/development environment has the following software installed and in a functional state: Visual Studio Code version 1.5 or later . Git version control . A Docker runtime environment such as Docker Desktop for Windows or macOS , Docker for Linux , etc.. WWT Programmability Foundations On-Demand Lab Requirements If you intend to use these instructions with the WWT Programmability Foundations On-Demand Lab , take note of the following advisories: The Visual Studio Code installation on the WWT Programmability Foundations On-Demand Lab requires an upgrade before it will successfully launch this development container. The WWT Programmability Foundations On-Demand Lab does not have Git for Windows pre-installed . The screenshots in the directions represent an example from a Microsoft Windows computer and the same procedures also work with macOS and Linux . Step 1 Clone the Git Repository : git clone https://github.com/wwt/devasc-data-formats.git // Insert image Step 2 Open Visual Studio Code: // Insert image Step 3 Install the Remote Development Pack Extension ms-vscode-remote.vscode-remote-extensionpack // Insert image Step 4 Initiate the Development Container Startup Process: // Insert image Step 5 Choose the Path to the cloned Git Repository: // Insert image Step 6 Open a web browser on your Docker runtime host. Navigate to the Container's JupyterLab server at http://localhost:8888 . Double-click on the part_i_python folder in the navigation pane. // Insert image Step 7 Open the file python.ipynb and begin working through the step-by-step instructions in the main pane: // Insert image Lab Environment Shutdown Close the Development Environment Container // Insert image","title":" Lab Setup Instructions"}]}